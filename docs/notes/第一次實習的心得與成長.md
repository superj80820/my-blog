---
title: 第一次實習的心得與成長
---

在2018的6月 我進到了一間Exosite物聯網公司實習測試工程師(QA)

對我原本做事的方法有很大的改變與幫助

在要離開前 我與一位資深工程師聊了MVC的概念

如果要做一個總結 我覺得剛剛好最後聊的主題剛好符合這一整年的歷程吧XDD

## Event Hook 的職責

在我們的物聯網系統中

有一個event hook的設計

devcie會依照cloud收到任意的event去觸發對應的程序

就跟webhook類似

以line webhook來說 就是使用者回覆了一個訊息

> line的clund就會hook(鉤住)一個程序 讓訊息送到指定的網址
> 但hook住的東西我們的並不在意說這個程序是否回傳值
> 所以不會影響到我們的主線程

而我們的device hook 就是

> 公司的clund會在觸發了某種event的時候連帶附加這些hook程序
> 例如clund接收到device的資料 我們就要依照這個資料
> 去觸發各種hook 我們不在意這些hook是否傳值
> 我們只要在意這些hook都有觸發

這樣講可能有點饒舌 舉個更簡單的例子

就是網頁的click event啦！

> 當我們觸發一個按鈕element
> 會發送一個event去js執行對應程序
> 但js並不能回傳值給按鈕

大家不覺得 evnet hook的概念 很難套用在MVC上嗎

至少我是覺得很難XDD

而我在evnet hook model 裡面看到了他在call其他controller

讓我非常吃驚 「這職責不對吧！」的聲音不斷在我腦袋打架

於是我請教了資深工程師 Q哥 得到了這些解答

## 用Event Hook的概念來為工作的事情做解答

首先 我最先的疑惑 就是是否可以不該稱為event hook model

而是該稱為event hook controller

> Q:
> 這就看每個人對這個字眼的理解了
> 光是controller這個字，每個人的理解可能都不一樣
> 所有東西都可以是controller，就跟所有東西都可以是component的意思一樣
> 如果要把hook叫成controller，那他大概就叫做event controller
> controller跟model只是被人類用來溝通而生出來的名詞而已

看了一臉矇逼的我 Q哥又舉了一個例子

> Q:
> 你可以寫一個會print('abc')的model給別人使用
> 確實可以reuse，每個import它的程式都會自動印出abc，但事實上一點也不實用
> 所以其實糾結在名詞之間的定義其實沒有太大的意義
> 像是controller應該做什麼，model應該做什麼，這都只是個概念而已
> 並沒有所謂的真理

所以說 只有在你的程式被使用時才會知道這個程式好不好用 而不是照著別人的定義寫出來的就是好程式

職責分清楚的好處就是別人來改你的程式時 可以很容易猜出要去哪個檔案改

但如果系統上面變得複雜 是否我們程式的職責就改變了呢 舉一個Q說的例子

> Q:
> Ａ只負責做底層的事情，Ｂ就是import Ａ把功能組一組變成最後要的東西
> 這樣子A這個檔案就不可能去import Ｂ，悲劇就不會發生
> 簡單的例子就是A只負責 加減乘除
> 而B可以做 算面積，所以就會 使用Ａ的 加減乘除 來實作 上底加下底乘以高除與2
> 以這個例子 A就是個model，B就是controller

但是 程式碼變多了之後呢

> Q:
> 如果把事情弄大一點，使用情境變成我有好多的面積要算，就會多一個C的檔案去import B的公式後，把所有運算結果加起來再給下一個程式
> 這時候B看起來就像model，C才是controller。
> 因為這公式基本上是不會變的，任何想用這個公式算面積的都可以import他

回到最初的module

當初那個print('abc')到底是不是個好module

就是看使用這個程式的人覺得好不好用

如果使用的人的需求就是永遠都印abc，那這個就足夠用了

一個程式好不好，我個人是覺得要看使用情境來定論

因為需求一直在改變，你很難從一個不會變需求的狀態下去設計你的程式

我一開始的觀點比較偏向於要遵守一個規範 才不會有重構問題

但實際上 重構 是人生必經之路的感覺

不論怎麼躲 都還是會有重構的可能性

> Q: 是的，重構我覺得是很正常的事情

那這麼說 不就代表討論這些設計模式沒有用 反正最後都有重構的可能性

> Q:
> 其實沒有答案
> 重構是花時間但卻對客戶來說沒有直接價值的東西
> 甚至重構是有把東西弄壞的風險（當初沒有unit test）
> 可是有時候客戶還是會想改一些小東西
> 所以每次改都會覺得再不重構我以後會很難處理
> 重構後
> 當初的決定是對是錯，只有在結果發生的時候才會驗證
> 比如說
> 你現在覺得這個東西要重構了，所以你去重構它
> 你可能花了一個禮拜重構了，看起來乾淨了，比較好管理了，但跑出來的結果肯定是沒有變
> 結果下一批intern來看到著個程式後，我覺得這個程式不好，我要重構他
> 這樣子的話當初的重構就是失敗的
> 或者是下一批人不熟悉這個語言，所以直接用他熟悉的語言寫了一模一樣的東西
> 當初的重構還是失敗的
> 但也有可能他們就照著你重構的東西用了好幾屆，這個重構就會是成功的
> 問題就是沒人會知道以後會發生什麼事，所以才沒有所謂真的答案

所以 討論這些設計模式 或是探討我們的code時 我們需要盡量避免邏輯職權不清楚的問題

所以我們必須探討時間上的成本 以及整個團隊的習性

我們要避免重構問題產生 但不要抗拒它

一個非常靈活的東西，他可以符合很多使用情境，所以應該很符合長期的使用

但這種東西要能靈活，一定是可以下很多參數之類的

裡面會是一對複雜而且參數化的東西

相對的就會變成 要懂他的人 才能用

而另一種隨便一個人來都會用的簡單程式，代價就是靈活度不高，因為無腦

可是兩種都是有使用者客群的

你可以想像你的客群是什麼，往那個方向去設計

回到 你不可能滿足所有人的需求，所以 你就可以做到你想要的東西

你只要讓你預期的客群覺得你的東西是好的就好了

---

所以 套用到一個我工作的事情上

在QA team我常常會與其他同事探討code的重複問題

使得我看到什麼tool 就想重構他

別人的 code review 都會搞很久

可是我實際上的產能高嗎？

坦白說我覺得還好 我為公司建立的價值並沒有很高

更多的時間我在「爭論」這些code上的問題

可是卻沒有完成很多簡單的事情

公司請我的原因 是希望我能夠完成這些自動化測試

而不是不斷想改善測試部門的文化

或許這可以對測試部門增加後續的產能 但這都是很無法直接看見的產能

所以 在往後思考一些對測試部門的想法時 應該思考到整個測試部門 而不是以個人的思維思考

<disqus />